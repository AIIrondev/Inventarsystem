{% extends "base.html" %}

{% block title %}Terminplan - Inventarsystem{% endblock %}

{% block content %}
<div class="calendar-container">
    <div class="calendar-header">
        <h1>Schulstunden-Terminplan für Ausleihen</h1>
        <div class="calendar-actions">
            <button id="prev-day">Vorheriger Tag</button>
            <span id="current-day-display"></span>
            <button id="next-day">Nächster Tag</button>
            <button id="today">Heute</button>
            <button id="new-booking" class="primary-button">Neue Reservierung</button>
        </div>
        <div class="calendar-legend">
            <span class="legend-item"><span class="legend-color current"></span> Aktuelle Ausleihungen</span>
            <span class="legend-item"><span class="legend-color planned"></span> Geplante Ausleihungen</span>
            <span class="legend-item"><span class="legend-color completed"></span> Abgeschlossene Ausleihungen</span>
            <span class="legend-item"><span class="legend-color your-bookings"></span> Ihre Ausleihungen</span>
        </div>
    </div>
    
    <div class="calendar-options">
        <label class="checkbox-container">
            <input type="checkbox" id="show-completed-bookings"> 
            Abgeschlossene Ausleihungen anzeigen
        </label>
    </div>
    
    <div id="calendar"></div>
    
    <!-- Notification area for alerts -->
    <div id="notification-area" class="notification-area"></div>
    
    <!-- Modal for new bookings -->
    <div id="booking-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Neue Reservierung</h2>
            <form id="booking-form">
                <div class="form-group">
                    <label for="booking-date">Datum:</label>
                    <input type="date" id="booking-date" name="booking_date" required>
                </div>
                <div class="form-group">
                    <label for="period-select">Schulstunde:</label>
                    <select id="period-select" name="period" required>
                        <option value="">-- Bitte wählen --</option>
                        {% for period, details in school_periods.items() %}
                        <option value="{{ period }}">{{ details.label }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="item-select">Objekt:</label>
                    <select id="item-select" name="item_id" required>
                        <option value="">-- Bitte wählen --</option>
                        <!-- Items will be loaded dynamically -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="booking-notes">Notizen:</label>
                    <textarea id="booking-notes" name="notes"></textarea>
                </div>
                <button type="submit" class="primary-button">Ausleihung speichern</button>
            </form>
        </div>
    </div>
    
    <!-- Modal for event details -->
    <div id="event-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Ausleihungs Details</h2>
            <div id="event-details">
                <!-- Event details will be loaded dynamically -->
            </div>
            <div id="event-actions">
                <button id="cancel-booking" class="danger-button">Ausleihung stornieren</button>
            </div>
        </div>
    </div>
</div>

<link href="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/locales/de.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize variables
    const calendarEl = document.getElementById('calendar');
    const bookingModal = document.getElementById('booking-modal');
    const eventModal = document.getElementById('event-modal');
    const newBookingBtn = document.getElementById('new-booking');
    const notificationArea = document.getElementById('notification-area');
    let currentEventId = null;
    let calendar;
    let showCompletedBookings = false;
    
    // School period times from server configuration - more robust parsing
    let schoolPeriods;
    try {
        schoolPeriods = JSON.parse('{{ school_periods|tojson|safe }}');
        console.log("Successfully parsed school periods:", schoolPeriods);
    } catch (e) {
        console.error("Error parsing school periods:", e);
        // Fallback to default periods if parsing fails
        schoolPeriods = {
            "1": { "start": "08:00", "end": "08:45", "label": "1. Stunde (08:00 - 08:45)" },
            "2": { "start": "08:45", "end": "09:30", "label": "2. Stunde (08:45 - 09:30)" },
            "3": { "start": "09:45", "end": "10:30", "label": "3. Stunde (09:45 - 10:30)" },
            "4": { "start": "10:30", "end": "11:15", "label": "4. Stunde (10:30 - 11:15)" },
            "5": { "start": "11:30", "end": "12:15", "label": "5. Stunde (11:30 - 12:15)" },
            "6": { "start": "12:15", "end": "13:00", "label": "6. Stunde (12:15 - 13:00)" },
            "7": { "start": "13:30", "end": "14:15", "label": "7. Stunde (13:30 - 14:15)" },
            "8": { "start": "14:15", "end": "15:00", "label": "8. Stunde (14:15 - 15:00)" },
            "9": { "start": "15:15", "end": "16:00", "label": "9. Stunde (15:15 - 16:00)" },
            "10": { "start": "16:00", "end": "16:45", "label": "10. Stunde (16:00 - 16:45)" }
        };
    }
    
    // Convert period to start/end times
    function getPeriodTimes(date, period) {
        const periodInfo = schoolPeriods[period];
        if (!periodInfo) return null;
        
        // Create a new date object with just the date component
        const newDate = new Date(date);
        newDate.setHours(0, 0, 0, 0); // Reset time to midnight
        
        // Extract hours and minutes from period definition
        const [startHours, startMinutes] = periodInfo.start.split(':').map(Number);
        const [endHours, endMinutes] = periodInfo.end.split(':').map(Number);
        
        // Create dates in the browser's local time zone with exact hours
        const startDate = new Date(newDate);
        startDate.setHours(startHours, startMinutes, 0, 0);
        
        const endDate = new Date(newDate);
        endDate.setHours(endHours, endMinutes, 0, 0);
        
        // Add timezone offset information for server-side handling
        const tzOffset = startDate.getTimezoneOffset();
        
        console.log(`Period ${period} times:`, {
            periodStart: periodInfo.start,
            periodEnd: periodInfo.end,
            calculatedStart: startDate.toLocaleTimeString(),
            calculatedEnd: endDate.toLocaleTimeString(),
            timezoneOffset: tzOffset
        });
        
        return {
            start: startDate,
            end: endDate,
            timezoneOffset: tzOffset
        };
    }
    
    // Get period from a time
    function getPeriodFromTime(date) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        
        for (const [period, times] of Object.entries(schoolPeriods)) {
            if (timeStr >= times.start && timeStr <= times.end) {
                return parseInt(period);
            }
        }
        return null;
    }

    // Simple notification function
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = message;
        
        notificationArea.appendChild(notification);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => {
                notification.remove();
            }, 500);
        }, 8000);
        
        console.log(`Notification (${type}): ${message}`);
    }
    
    // Create direct manual rendering of events
    function createManualEvents(events) {
        console.log('Creating manual events:', events.length);
        
        // Try/catch the entire function to avoid global failures
        try {
            // Find the container where we'll add our events
            const container = document.querySelector('.fc-timegrid-body');
            if (!container) {
                console.error('Could not find calendar grid container');
                
                // Try fallback containers - with added error protection
                const fallbackContainer = document.querySelector('.fc-view-harness') || 
                                        document.querySelector('.fc') ||
                                        document.getElementById('calendar');
                
                if (!fallbackContainer) {
                    console.error('Could not find any suitable calendar container');
                    // Last resort fallback - just add to the body if we can't find the calendar
                    createFloatingEvents(events, document.body);
                    return;
                }
                
                console.log('Using fallback container:', fallbackContainer);
                createFloatingEvents(events, fallbackContainer);
                return;
            }
            
            // Remove any existing manual events
            document.querySelectorAll('.manual-calendar-event').forEach(el => el.remove());
            
            // Create container for manual events with clearer positioning
            const manualEventsContainer = document.createElement('div');
            manualEventsContainer.className = 'manual-events-container';
            Object.assign(manualEventsContainer.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                right: '0',
                bottom: '0',
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                zIndex: '2000',
                overflow: 'visible'
            });
            container.appendChild(manualEventsContainer);
            
            console.log('Created manual events container, container size:', container.offsetWidth, container.offsetHeight);
            
            // Count of successfully created events
            let createdCount = 0;
            
            // Set up timing values
            const startTime = 8; // 8:15 AM
            const endTime = 16.75;    // 4:45 PM
            const timespanHours = endTime - startTime;
            
            // Process each event
            events.forEach(event => {
                try {
                    // Parse dates from ISO strings if needed
                    let startDate, endDate;
                    
                    if (typeof event.start === 'string') {
                        startDate = new Date(event.start);
                    } else if (event.start instanceof Date) {
                        startDate = event.start;
                    } else {
                        console.warn('Invalid start date for manual event:', event.start);
                        return;
                    }
                    
                    if (typeof event.end === 'string') {
                        endDate = new Date(event.end);
                    } else if (event.end instanceof Date) {
                        endDate = event.end;
                    } else {
                        endDate = new Date(startDate.getTime() + 45*60000); // Default 45 min
                    }
                    
                    // Create the manual event element
                    const manualEvent = document.createElement('div');
                    manualEvent.className = 'manual-calendar-event';
                    manualEvent.setAttribute('data-event-id', event.id);
                    
                    // Add stronger styling for high visibility - with explicit !important flags
                    Object.assign(manualEvent.style, {
                        position: 'absolute',
                        backgroundColor: event.backgroundColor || '#3788d8',
                        color: 'white',
                        borderRadius: '3px',
                        padding: '8px',
                        boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
                        overflow: 'hidden', 
                        pointerEvents: 'auto',
                        cursor: 'pointer',
                        zIndex: '5000',
                        border: '2px solid ' + (event.borderColor || '#2c6aa0'),
                        fontWeight: 'bold',
                        fontSize: '12px',
                        minHeight: '40px', 
                        visibility: 'visible !important',
                        display: 'block !important',
                        opacity: '1 !important'
                    });
                    
                    // Calculate column position
                    manualEvent.style.left = '50px';
                    manualEvent.style.right = '50px';
                    
                    // Calculate vertical position - simpler positioning logic
                    const startHour = startDate.getHours() + (startDate.getMinutes() / 60);
                    const endHour = endDate.getHours() + (endDate.getMinutes() / 60);
                    
                    // Calculate position relative to visible time range
                    // Make sure position is constrained to the visible area
                    let relativeStart = Math.max(0, (startHour - startTime) / timespanHours);
                    let relativeEnd = Math.min(1, (endHour - startTime) / timespanHours);
                    
                    if (relativeEnd <= 0 || relativeStart >= 1) {
                        // Event is outside visible range
                        console.log(`Event outside visible range: ${startHour}-${endHour}`);
                        return;
                    }
                    
                    // Constrain to visible area
                    relativeStart = Math.max(0, relativeStart);
                    relativeEnd = Math.min(1, relativeEnd);
                    
                    // Convert to pixels (percentage of container)
                    const containerHeight = container.offsetHeight;
                    const top = Math.floor(relativeStart * containerHeight);
                    const height = Math.max(40, Math.floor((relativeEnd - relativeStart) * containerHeight));
                    
                    // Apply positioning
                    manualEvent.style.top = `${top}px`;
                    manualEvent.style.height = `${height}px`;
                    
                    // Event content with more detailed information
                    manualEvent.innerHTML = `
                        <div style="font-weight:bold;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
                            ${event.title}
                        </div>
                        <div style="font-size:11px;margin-top:3px;">
                            ${startDate.getHours()}:${String(startDate.getMinutes()).padStart(2, '0')} - 
                            ${endDate.getHours()}:${String(endDate.getMinutes()).padStart(2, '0')}
                        </div>
                        <div style="font-size:10px;margin-top:2px;opacity:0.9;">
                            ${event.extendedProps?.userName || 'Unknown'}
                        </div>
                    `;
                    
                    // Add period badge if available
                    if (event.extendedProps && event.extendedProps.period) {
                        const periodBadge = document.createElement('div');
                        Object.assign(periodBadge.style, {
                            position: 'absolute',
                            right: '5px',
                            top: '5px',
                            fontSize: '10px',
                            padding: '2px 4px',
                            borderRadius: '3px',
                            backgroundColor: 'rgba(255,255,255,0.3)',
                            fontWeight: 'bold'
                        });
                        periodBadge.textContent = event.extendedProps.period + '. Std';
                        manualEvent.appendChild(periodBadge);
                    }
                    
                    // Add click handler
                    manualEvent.addEventListener('click', () => {
                        if (typeof showEventDetails === 'function') {
                            showEventDetails(event);
                        }
                    });
                    
                    // Add to container
                    manualEventsContainer.appendChild(manualEvent);
                    createdCount++;
                    
                    console.log(`Created manual event: "${event.title}" at ${top}px (${startHour}h)`);
                } catch (e) {
                    console.error('Error creating manual event:', e, event);
                }
            });
            
            console.log(`Successfully created ${createdCount} manual events out of ${events.length}`);
            
            // Add a visual indicator that we're in manual mode
            const indicator = document.createElement('div');
            Object.assign(indicator.style, {
                position: 'fixed',  // Changed to fixed for better visibility
                top: '10px',
                right: '10px',
                backgroundColor: '#e74c3c',
                color: 'white',
                padding: '5px 10px',
                borderRadius: '3px',
                fontWeight: 'bold',
                zIndex: '5500',
                fontSize: '12px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
            });
            indicator.textContent = 'Manueller Anzeigemodus';
            document.body.appendChild(indicator);  // Add to body to ensure visibility
        } catch (e) {
            console.error('Fatal error in manual event creation:', e);
            // Last resort emergency display
            try {
                // Create a simple notification element as absolute last resort
                const emergencyContainer = document.createElement('div');
                emergencyContainer.style.position = 'fixed';
                emergencyContainer.style.top = '20%';
                emergencyContainer.style.left = '20%';
                emergencyContainer.style.right = '20%';
                emergencyContainer.style.backgroundColor = '#f8d7da';
                emergencyContainer.style.color = '#721c24';
                emergencyContainer.style.padding = '20px';
                emergencyContainer.style.borderRadius = '5px';
                emergencyContainer.style.zIndex = '9999';
                emergencyContainer.style.boxShadow = '0 5px 15px rgba(0,0,0,0.5)';
                
                const header = document.createElement('h3');
                header.textContent = 'Kalenderanzeige konnte nicht geladen werden';
                emergencyContainer.appendChild(header);
                
                const message = document.createElement('p');
                message.textContent = `Es gibt ${events.length} Termine, die nicht angezeigt werden können.`;
                emergencyContainer.appendChild(message);
                
                const eventsList = document.createElement('ul');
                events.slice(0, 5).forEach(event => {
                    const li = document.createElement('li');
                    li.textContent = `${event.title} (ID: ${event.id})`;
                    eventsList.appendChild(li);
                });
                emergencyContainer.appendChild(eventsList);
                
                document.body.appendChild(emergencyContainer);
            } catch (finalError) {
                // At this point we've tried everything we can
                console.error('Complete failure in event rendering:', finalError);
                alert('Fehler beim Rendern der Kalenderereignisse. Bitte laden Sie die Seite neu.');
            }
        }
    }

    // Alternative approach for when the normal container isn't available
    function createFloatingEvents(events, container) {
        console.log('Creating floating events:', events.length);
        // Implementation for floating events
    }

    // Create a debug overlay to show where events should be - SIMPLIFIED VERSION
    function createDebugOverlay(events) {
        console.log("Using simplified debug overlay as fallback");
        // Just call our manual event renderer which is more robust
        createManualEvents(events);
    }

    // Add simple self-healing function
    function checkAndFixEvents() {
        console.log("Running self-healing event check");
        try {
            const events = calendar.getEvents();
            if (!events || !Array.isArray(events)) {
                console.log('No valid events array found');
                return;
            }
            
            const visibleEvents = document.querySelectorAll('.fc-event').length;
            
            if (events.length > 0 && visibleEvents === 0) {
                console.log('Self-healing: Events exist but are not visible. Creating manual events...');
                createManualEvents(events);
            }
        } catch (e) {
            console.error('Error in self-healing function:', e);
        }
    }

    // Initialize calendar with expanded debugging
    console.log('Initializing calendar with container size:', calendarEl.offsetWidth, calendarEl.offsetHeight);
    calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'timeGridDay',
        locale: 'de',
        headerToolbar: false, // We're using our custom header
        navLinks: true,
        editable: false,
        dayMaxEvents: true,
        allDaySlot: false,
        slotMinTime: '08:00:00', 
        slotMaxTime: '16:45:00',
        slotDuration: '00:45:00', 
        snapDuration: '00:45:00',
        scrollTime: '08:00:00',
        nowIndicator: true,
        now: new Date(),
        timeZone: 'local',
        displayEventTime: true,
        height: 'auto', // Let the calendar adjust to content
        contentHeight: 'auto', // Let the calendar adjust to content
        handleWindowResize: true, // Ensure it resizes with the window
        eventDisplay: 'block',        // Force block display mode
        forceEventDuration: true,     // Ensure events have a duration
        eventTimeFormat: {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
        },
        selectAllow: function(info) {
            const startHour = info.start.getHours();
            const endHour = info.end.getHours();
            return startHour >= 8 && endHour <= 17;
        },
        events: function(info, successCallback, failureCallback) {
            const startStr = info.startStr;
            const endStr = info.endStr;
            
            console.log(`Fetching events from ${startStr} to ${endStr}`);
            
            // Load events from the server
            fetch('/get_bookings?start=' + startStr + '&end=' + endStr)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Extract bookings from response with detailed logging
                    const bookingsArray = Array.isArray(data) ? data : (data.bookings || []);
                    console.log("Raw event data received:", bookingsArray);
                    
                    if (bookingsArray.length === 0) {
                        console.log("No events received from server for this period");
                    }
                    
                    // Process events to add colors based on status
                    let processedEvents = bookingsArray.map(event => {
                        // Debug individual event
                        console.log("Processing event:", event);
                        
                        let eventColor = '#3788d8'; // Default color
                        
                        if (event.isCurrentUser) {
                            eventColor = '#8e44ad'; // Purple for current user's bookings
                        } else if (event.status === 'completed') {
                            eventColor = '#7f8c8d'; // Gray for completed bookings
                        } else if (event.status === 'current') {
                            eventColor = '#e74c3c'; // Red for current bookings
                        } else if (event.status === 'planned') {
                            eventColor = '#2ecc71'; // Green for planned bookings
                        }
                        
                        // Ensure we have valid dates for start and end
                        let startTime, endTime;
                        try {
                            startTime = new Date(event.start);
                            endTime = new Date(event.end);
                            
                            // Add debugging for time conversion
                            console.log(`Event time conversion for ${event.id}:`, {
                                originalStart: event.start,
                                originalEnd: event.end,
                                parsedStart: startTime.toString(),
                                parsedEnd: endTime.toString(),
                                localStart: startTime.toLocaleString(),
                                localEnd: endTime.toLocaleString()
                            });
                            
                            // Verify dates are valid
                            if (isNaN(startTime) || isNaN(endTime)) {
                                console.error("Invalid date for event:", event);
                                // Use fallback values if dates are invalid
                                const now = new Date();
                                startTime = now;
                                endTime = new Date(now.getTime() + 45*60000); // 45 minutes later
                            }
                        } catch (e) {
                            console.error("Error parsing dates for event:", e, event);
                            const now = new Date();
                            startTime = now;
                            endTime = new Date(now.getTime() + 45*60000);
                        }
                        
                        // Add direct debugging elements
                        const debugInfo = {
                            id: event.id,
                            title: event.title || "Unnamed Event",
                            startTime: startTime.toLocaleString(),
                            endTime: endTime.toLocaleString()
                        };
                        
                        // Create the processed event object
                        const processedEvent = {
                            id: event.id,
                            title: event.title || "Unnamed Event",
                            start: startTime.toISOString(),
                            end: endTime.toISOString(),
                            allDay: false, // Explicitly set to false for time-based events
                            extendedProps: {
                                itemId: event.itemId,
                                userName: event.userName || "Unknown User",
                                notes: event.notes || "",
                                status: event.status || "unknown",
                                isCurrentUser: Boolean(event.isCurrentUser),
                                period: event.period,
                                debugInfo: debugInfo
                            },
                            backgroundColor: eventColor,
                            borderColor: eventColor,
                            textColor: '#ffffff',
                            display: 'block', // Use 'block' for better visibility
                            classNames: [
                                (event.status || "unknown") + '-event',
                                event.isCurrentUser ? 'user-event' : '',
                                'custom-event',
                                'fc-event-forced-visible'
                            ]
                        };
                        
                        console.log("Created processed event:", processedEvent);
                        return processedEvent;
                    });
                    
                    // Filter completed if needed
                    const filteredEvents = showCompletedBookings 
                        ? processedEvents 
                        : processedEvents.filter(event => event.extendedProps.status !== 'completed');
                    
                    console.log(`Processed ${processedEvents.length} events, displaying ${filteredEvents.length}`);
                    if (filteredEvents.length > 0) {
                        console.log("First event sample:", filteredEvents[0]);
                    } else {
                        console.log("No events to display after filtering");
                    }
                    
                    // Add direct rendering after event processing
                    setTimeout(() => {
                        calendar.removeAllEvents();
                        calendar.addEventSource(filteredEvents);
                    }, 100);
                    
                    // Successfully provide events to calendar
                    successCallback(filteredEvents);
                    
                    // Visual confirmation that events are loaded
                    showNotification(`${filteredEvents.length} Ausleihungen geladen`, 'info');
                    
                    // Create a visible debug overlay if events are present but not visible
                    if (filteredEvents.length > 0) {
                        setTimeout(() => {
                            try {
                                const visibleEvents = document.querySelectorAll('.fc-event').length;
                                if (visibleEvents === 0) {
                                    console.warn("Events were processed but none are visible in the DOM!");
                                    // Direct call to createManualEvents instead of createDebugOverlay
                                    createManualEvents(filteredEvents);
                                } else {
                                    console.log(`${visibleEvents} events found in DOM`);
                                }
                            } catch (e) {
                                console.error("Error checking for visible events:", e);
                                // If there's an error, try to render the events directly
                                try {
                                    createManualEvents(filteredEvents);
                                } catch (innerError) {
                                    console.error("Failed to create manual events:", innerError);
                                }
                            }
                        }, 1000);
                    }
                    
                    // Force a complete refresh of the calendar
                    setTimeout(() => {
                        calendar.updateSize();
                        calendar.render(); // Force re-render everything
                    }, 200);
                })
                .catch(error => {
                    console.error('Error loading bookings:', error);
                    failureCallback(error);
                    showNotification('Fehler beim Laden der Ausleihungen: ' + error.message, 'error');
                });
        },
        eventDidMount: function(info) {
            console.log("Event mounted:", info.event.title, info.el);
            
            // DEBUG - Style the element directly to ensure visibility
            info.el.style.zIndex = '100';
            info.el.style.position = 'absolute';
            info.el.style.backgroundColor = info.event.backgroundColor;
            info.el.style.borderColor = info.event.borderColor;
            info.el.style.color = '#fff';
            info.el.style.padding = '4px 6px';
            info.el.style.borderRadius = '3px';
            info.el.style.fontWeight = 'bold';
            info.el.style.margin = '1px 0';
            info.el.style.opacity = '1';
            info.el.style.visibility = 'visible';
            info.el.style.display = 'block';
            info.el.style.pointerEvents = 'auto';
            
            // Add a visible debug indicator to every event
            const debugDot = document.createElement('div');
            debugDot.className = 'debug-dot';
            debugDot.style.width = '8px';
            debugDot.style.height = '8px';
            debugDot.style.borderRadius = '50%';
            debugDot.style.backgroundColor = '#ff0000';
            debugDot.style.position = 'absolute';
            debugDot.style.top = '0';
            debugDot.style.right = '0';
            debugDot.style.zIndex = '101';
            info.el.appendChild(debugDot);
            
            // Add custom attributes for styling
            if (info.event.extendedProps.isCurrentUser) {
                info.el.setAttribute('data-is-current-user', 'true');
                info.el.classList.add('user-event-visible');
            }
            
            // Add visible period marker if available
            if (info.event.extendedProps.period) {
                const periodDiv = document.createElement('div');
                periodDiv.className = 'fc-event-period-marker';
                periodDiv.textContent = info.event.extendedProps.period + '. Std';
                periodDiv.style.backgroundColor = 'rgba(255,255,255,0.3)';
                periodDiv.style.borderRadius = '3px';
                periodDiv.style.padding = '1px 3px';
                periodDiv.style.marginTop = '2px';
                periodDiv.style.display = 'inline-block';
                periodDiv.style.fontSize = '10px';
                info.el.appendChild(periodDiv);
            }
            
            // Add borrowed indicator if relevant
            if (info.event.extendedProps.itemBorrower && 
                info.event.extendedProps.itemBorrower !== info.event.extendedProps.userName) {
                
                const borrowerIndicator = document.createElement('div');
                borrowerIndicator.className = 'borrowed-indicator';
                borrowerIndicator.innerHTML = '⚠️';  // Warning symbol
                borrowerIndicator.title = `Bereits ausgeliehen von: ${info.event.extendedProps.itemBorrower}`;
                borrowerIndicator.style.position = 'absolute';
                borrowerIndicator.style.top = '2px';
                borrowerIndicator.style.left = '2px';
                borrowerIndicator.style.zIndex = '102';
                borrowerIndicator.style.fontSize = '12px';
                info.el.appendChild(borrowerIndicator);
                
                // Add a class to style the event differently
                info.el.classList.add('already-borrowed');
            }
        },
        eventClick: function(info) {
            console.log("Event clicked:", info.event.title);
            showEventDetails(info.event);
        },
        datesSet: function(dateInfo) {
            console.log("Calendar dates set:", dateInfo.start, dateInfo.end);
        }
    });

    // Render calendar with more robust error handling and add additional fixes
    try {
        console.log('Rendering calendar and checking for events');
        calendar.render();
        console.log('Calendar rendered successfully');
        
        // Override FullCalendar CSS directly to ensure visibility
        const styleOverrides = document.createElement('style');
        styleOverrides.textContent = `
            /* Force event visibility */
            .fc-timegrid-event-harness, 
            .fc-timegrid-event, 
            .fc-daygrid-event-harness,
            .fc-daygrid-event,
            .fc-event-main,
            .fc-event-main-frame,
            .fc-event,
            .fc-event-forced-visible {
                opacity: 1 !important;
                visibility: visible !important;
                display: block !important;
                position: absolute !important;
                z-index: 999 !important;
                pointer-events: auto !important;
            }
            
            /* Ensure proper containment */
            .fc-view-harness,
            .fc-timegrid,
            .fc-timegrid-body,
            .fc-timegrid-slots,
            .fc-timegrid-cols,
            .fc-timegrid-col {
                overflow: visible !important;
            }
        `;
        document.head.appendChild(styleOverrides);
        
        // Multiple refresh attempts with different strategies
        setTimeout(() => {
            calendar.updateSize();
            console.log('Calendar size updated');
            
            // Check for rendered events
            const events = document.querySelectorAll('.fc-event');
            console.log(`Found ${events.length} event elements in DOM after rendering`);
            
            // Force calendar to completely reload
            calendar.refetchEvents();
        }, 500);
        
        // Try another refresh after a delay
        setTimeout(() => {
            console.log('Forcing initial event refresh');
            calendar.refetchEvents();
            
            // Apply our manual rendering if needed
            checkAndFixEvents();
        }, 1000);
        
        // Final attempt
        setTimeout(() => {
            console.log('Forcing secondary event refresh');
            calendar.refetchEvents();
            
            // Check again
            const events = document.querySelectorAll('.fc-event');
            console.log(`Found ${events.length} event elements in DOM after refresh`);
            
            // Final manual rendering if still needed
            checkAndFixEvents();
        }, 2500);
        
    } catch (e) {
        console.error("Error rendering calendar:", e);
        showNotification('Fehler beim Rendern des Kalenders: ' + e.message, 'error');
    }
    
    updateCurrentDayDisplay();
    
    // Custom navigation buttons
    document.getElementById('prev-day').addEventListener('click', function() {
        calendar.prev();
        updateCurrentDayDisplay();
    });
    
    document.getElementById('next-day').addEventListener('click', function() {
        calendar.next();
        updateCurrentDayDisplay();
    });
    
    document.getElementById('today').addEventListener('click', function() {
        calendar.today();
        updateCurrentDayDisplay();
    });
    
    // Update the current day display
    function updateCurrentDayDisplay() {
        const dateStr = calendar.view.title;
        document.getElementById('current-day-display').textContent = dateStr;
    }
    
    // Load available items for the booking form
    function loadAvailableItems() {
        const itemSelect = document.getElementById('item-select');
        itemSelect.innerHTML = '<option value="">-- Bitte wählen --</option>';
        
        fetch('/get_items?available_only=true')
            .then(response => response.json())
            .then(data => {
                // Access the items array in the response
                const items = data.items || [];
                
                items.forEach(item => {
                    // Include all items, even if not immediately available
                    // Availability will be checked when booking
                    const option = document.createElement('option');
                    const itemId = item._id.$oid || item._id || item.id;
                    option.value = itemId;
                    option.textContent = item.Name;
                    itemSelect.appendChild(option);
                });
                
                if (items.length === 0) {
                    itemSelect.innerHTML += '<option value="" disabled>Keine Objekte gefunden</option>';
                    console.log('No items found');
                } else {
                    console.log(`Loaded ${items.length} items into dropdown`);
                }
            })
            .catch(error => console.error('Error loading items:', error));
    }
    
    // Open booking modal
    function openBookingModal(date = null) {
        // Set date to today if not provided
        if (!date) {
            date = calendar.getDate();
        }
        
        // Format the date for the date picker
        const formatDate = (date) => {
            return date.toISOString().split('T')[0];
        };
        
        document.getElementById('booking-date').value = formatDate(date);
        
        // Load available items
        loadAvailableItems();
        
        // Show modal
        bookingModal.style.display = 'block';
    }
    
    // Show event details
    function showEventDetails(event) {
        const details = document.getElementById('event-details');
        const actions = document.getElementById('event-actions');
        
        // Set current event ID
        currentEventId = event.id;
        
        // Get status text based on status value
        let statusText = 'Unbekannt';
        if (event.extendedProps.status === 'current') {
            statusText = 'Aktuell ausgeliehen';
        } else if (event.extendedProps.status === 'planned') {
            statusText = 'Geplant';
        } else if (event.extendedProps.status === 'completed') {
            statusText = 'Abgeschlossen';
        }
        
        // Get period information if available
        let periodText = '';
        if (event.extendedProps.period) {
            const period = event.extendedProps.period;
            if (schoolPeriods[period]) {
                periodText = `<p><strong>Schulstunde:</strong> ${schoolPeriods[period].label}</p>`;
            }
        }
        
        // Check if item is already borrowed by someone else
        let borrowerInfo = '';
        if (event.extendedProps.itemBorrower && event.extendedProps.itemBorrower !== event.extendedProps.userName) {
            borrowerInfo = `<p class="warning"><strong>Hinweis:</strong> Dieses Objekt ist aktuell ausgeliehen von <strong>${event.extendedProps.itemBorrower}</strong></p>`;
        }
        
        // Populate details
        details.innerHTML = `
            <p><strong>Objekt:</strong> ${event.title}</p>
            <p><strong>Datum:</strong> ${new Date(event.start).toLocaleDateString('de-DE')}</p>
            <p><strong>Von:</strong> ${new Date(event.start).toLocaleTimeString('de-DE', {hour: '2-digit', minute:'2-digit'})}</p>
            <p><strong>Bis:</strong> ${new Date(event.end).toLocaleTimeString('de-DE', {hour: '2-digit', minute:'2-digit'})}</p>
            ${periodText}
            <p><strong>Ausgeliehen von:</strong> ${event.extendedProps.userName}</p>
            ${event.extendedProps.notes ? `<p><strong>Notizen:</strong> ${event.extendedProps.notes}</p>` : ''}
            <p><strong>Status:</strong> ${statusText}</p>
            ${borrowerInfo}
        `;
        
        // Show/hide cancel button based on ownership and status
        // Only allow cancellation for planned bookings that belong to the current user
        if (event.extendedProps.isCurrentUser && event.extendedProps.status === 'planned') {
            actions.style.display = 'block';
        } else {
            actions.style.display = 'none';
        }
        
        // Show modal
        eventModal.style.display = 'block';
    }
    
    // New booking button
    newBookingBtn.addEventListener('click', function() {
        openBookingModal();
    });
    
    // Close modals when clicking X
    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', function() {
            bookingModal.style.display = 'none';
            eventModal.style.display = 'none';
        });
    });
    
    // Close modals when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target === bookingModal) {
            bookingModal.style.display = 'none';
        }
        if (event.target === eventModal) {
            eventModal.style.display = 'none';
        }
    });
    
    // Booking form submission
    document.getElementById('booking-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const formData = new FormData(this);
        
        // Log form data for basic tracking
        const formValues = {};
        for (let [key, value] of formData.entries()) {
            formValues[key] = value;
        }
        console.log('Booking form submitted', formValues);
        
        // Add period information to the form data
        const bookingDate = new Date(formData.get('booking_date'));
        const periodNum = formData.get('period');
        
        // Get the period times with verification
        const periodTimes = getPeriodTimes(bookingDate, periodNum);
        
        if (!periodTimes) {
            showNotification('Ungültige Schulstunde ausgewählt!', 'error');
            return;
        }
        
        // Verify the times are in the correct range
        const startHour = periodTimes.start.getHours();
        if (startHour < 8 || startHour > 16) {
            console.error('Invalid hour generated:', startHour);
            showNotification('Fehler: Ungültiger Zeitraum erzeugt!', 'error');
            return;
        }
        
        // Format dates for backend
        const startDate = new Date(periodTimes.start);
        const endDate = new Date(periodTimes.end);

        const formatDateForServer = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        };

        formData.append('start_date', formatDateForServer(startDate));
        formData.append('end_date', formatDateForServer(endDate));
        
        const itemId = formData.get('item_id');
        const notes = formData.get('notes');
        
        // Show loading notification
        showNotification('Reservierung wird geprüft...', 'info');
        
        fetch('/plan_booking', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return response.json().then(data => {
                    return { 
                        status: response.status,
                        data: data
                    };
                });
            }
            throw new Error('Unexpected response format');
        })
        .then(result => {
            const { status, data } = result;
            
            if (data.success) {
                // Close modal and refresh calendar
                bookingModal.style.display = 'none';
                
                showNotification('Ausleihe erfolgreich geplant!', 'success');
                
                // Force-refresh the calendar
                setTimeout(() => {
                    console.log('Refreshing calendar after successful booking');
                    // Just refetch events - this is the correct method
                    calendar.refetchEvents();
                    
                    // In rare cases, changing the view can help
                    const currentView = calendar.view.type;
                    calendar.changeView('listDay');
                    setTimeout(() => calendar.changeView(currentView), 100);
                }, 1000); 
            } else {
                const errorMsg = data.error || 'Unbekannter Fehler';
                showNotification('Fehler: ' + errorMsg, 'error');
            }
        })
        .catch(error => {
            console.error('Error submitting booking:', error);
            showNotification(
                'Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.', 
                'error'
            );
        });
    });
    
    // Cancel booking
    document.getElementById('cancel-booking').addEventListener('click', function() {
        if (confirm('Möchten Sie diese Ausleihe wirklich stornieren?')) {
            fetch('/cancel_booking/' + currentEventId, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    eventModal.style.display = 'none';
                    calendar.refetchEvents();
                    showNotification('Ausleihe erfolgreich storniert!', 'success');
                } else {
                    showNotification('Fehler: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error canceling booking:', error);
                showNotification('Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.', 'error');
            });
        }
    });

    document.getElementById('show-completed-bookings').addEventListener('change', function() {
        showCompletedBookings = this.checked;
        calendar.refetchEvents();
    });

    // On initial page load, add an extra attempt to render events manually
    setTimeout(() => {
        try {
            const events = calendar.getEvents();
            const visibleEvents = document.querySelectorAll('.fc-event').length;
            
            if (events.length > 0 && visibleEvents === 0) {
                console.log('Initial load: Events exist but are not visible. Creating manual events...');
                createManualEvents(events);
            }
            
            // Set up periodic self-healing with error handling
            setInterval(() => {
                try {
                    checkAndFixEvents();
                } catch (e) {
                    console.error('Error in self-healing interval:', e);
                }
            }, 5000);
        } catch (e) {
            console.error('Error in initial manual rendering check:', e);
        }
    }, 1500);
});
</script>

<style>
.calendar-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.calendar-header {
    margin-bottom: 20px;
}

.calendar-actions {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    flex-wrap: wrap; /* Allow items to wrap on small screens */
    gap: 10px; /* Add gap between items */
}

.calendar-actions button {
    background-color: #f0f0f0;
    border: 1px solid #ddd;
    padding: 5px 10px;
    margin: 0;  /* Remove horizontal margins */
    cursor: pointer;
    white-space: nowrap;  /* Prevent button text from wrapping */
}

.calendar-actions .primary-button {
    background-color: #3788d8;
    color: white;
    margin-left: auto;
}

#current-day-display {
    font-weight: bold;
    margin: 0 15px;
    min-width: 150px;
    text-align: center;
}

/* Mobile responsive adjustments */
@media (max-width: 768px) {
    .calendar-actions {
        justify-content: center; /* Center items on mobile */
        flex-direction: column; /* Stack buttons vertically on very small screens */
        margin-bottom: 15px;
    }
    
    .calendar-actions button {
        width: 100%; /* Full width buttons on mobile */
        margin: 5px 0; /* Add vertical spacing between buttons */
    }
    
    .calendar-actions .primary-button {
        margin-left: 0; /* Reset margin on mobile */
        order: -1; /* Place the primary button first */
    }
    
    #current-day-display {
        margin: 10px 0;
        text-align: center;
    }

    .calendar-legend {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .legend-item {
        margin-bottom: 8px;
    }
}

.calendar-legend {
    display: flex;
    margin-top: 10px;
}

.legend-item {
    display: flex;
    align-items: center;
    margin-right: 20px;
}

.legend-color {
    display: inline-block;
    width: 15px;
    height: 15px;
    margin-right: 5px;
    border-radius: 50%;
}

.legend-color.current {
    background-color: #e74c3c;
}

.legend-color.planned {
    background-color: #2ecc71;
}

.legend-color.completed {
    background-color: #7f8c8d;
}

.legend-color.your-bookings {
    background-color: #8e44ad;
}

/* Add to existing styles */
.calendar-options {
    margin: 10px 0;
}

.checkbox-container {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
}

.checkbox-container input {
    margin-right: 8px;
}

/* Notification area */
.notification-area {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    width: 300px;
}

.notification {
    background-color: #fff;
    border-left: 4px solid #3788d8;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    padding: 15px;
    margin-bottom: 10px;
    animation: slideIn 0.3s ease-out;
}

.notification.success {
    border-left-color: #2ecc71;
}

.notification.error {
    border-left-color: #e74c3c;
}

.notification.warning {
    border-left-color: #f39c12;
}

.notification.fade-out {
    animation: fadeOut 0.5s ease-in forwards;
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

/* Modal styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
}

.modal-content {
    background-color: white;
    margin: 10% auto;
    padding: 20px;
    border-radius: 5px;
    max-width: 500px;
    position: relative;
}

.close {
    position: absolute;
    right: 20px;
    top: 10px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
}

.form-group input, .form-group select, .form-group textarea {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.primary-button {
    background-color: #3788d8;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
}

.danger-button {
    background-color: #e74c3c;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
}

/* Make the day view time slots more readable */
.fc-timegrid-slot {
    height: 3em !important;
    position: relative !important;
    z-index: 1 !important;
}

/* Ensure calendar container is properly sized */
#calendar {
    min-height: 600px;
    width: 100%;
    margin-bottom: 30px;
    position: relative;
    z-index: 1;
}

/* Highlight the periods */
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="08:00:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="08:45:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="09:45:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="10:30:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="11:30:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="12:15:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="13:30:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="14:15:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="15:15:00"],
.fc-timegrid-slot.fc-timegrid-slot-lane[data-time="16:00:00"] {
    border-top: 2px solid #3788d8;
}

/* Now indicator styles */
.fc .fc-timegrid-now-indicator-line {
    border-color: #3788d8 !important;
    border-width: 2px !important;
    z-index: 999 !important;
}

.fc .fc-timegrid-now-indicator-arrow {
    border-color: #3788d8 !important;
    border-width: 5px !important;
}

.error { color: #e74c3c; }
.warning { color: #f39c12; }
.success { color: #2ecc71; }

/* Make booked periods more visible */
.fc-event {
    border-width: 2px !important;
    font-weight: bold !important;
    padding: 2px 4px !important;
    min-height: 24px !important;
    position: relative !important;
    z-index: 5 !important;
    margin: 1px 0 !important;
    opacity: 1 !important;
}

/* Add shadow to the current user's bookings for better visibility */
.fc-event[data-is-current-user="true"] {
    box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
    z-index: 10 !important; /* Make sure user's events appear on top */
}

/* Period marker within the event */
.fc-event-period-marker {
    font-size: 10px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
    padding: 1px 3px;
    margin-top: 2px;
    display: inline-block;
}

/* Add custom colors for event types to make them more distinct */
.fc-event.planned-event {
    background-color: #2ecc71 !important;
    border-color: #27ae60 !important;
}

.fc-event.current-event {
    background-color: #e74c3c !important;
    border-color: #c0392b !important;
}

.fc-event.completed-event {
    background-color: #7f8c8d !important;
    border-color: #34495e !important;
    opacity: 0.8;
}

.fc-event.user-event {
    background-color: #8e44ad !important;
    border-color: #9b59b6 !important;
}

/* Make time slots for school periods more recognizable */
.fc-timegrid-slot:nth-child(odd) {
    background-color: rgba(240, 240, 245, 0.4);
}

/* Time overflow indicators styles */
.time-overflow-container {
    width: 100%;
    background-color: #f8f8f8;
    border: 1px solid #ddd;
    padding: 5px;
    margin-bottom: 10px;
    z-index: 10;
}

.before-container {
    border-bottom: 2px dashed #aaa;
    margin-top: -5px;
    position: relative;
    max-height: 150px;
    overflow-y: auto;
}

.after-container {
    border-top: 2px dashed #aaa;
    margin-bottom: -5px;
    position: relative;
    max-height: 150px;
    overflow-y: auto;
}

.overflow-event-item {
    display: flex;
    justify-content: space-between;
    padding: 5px 8px;
    margin: 3px 0;
    border-radius: 3px;
    color: white;
    font-size: 12px;
    cursor: pointer;
    transition: opacity 0.2s;
}

.overflow-event-item:hover {
    opacity: 0.9;
}

.overflow-event-time {
    font-weight: bold;
    margin-right: 5px;
}

.overflow-event-title {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.before-event {
    border-left: 4px solid;
}

.after-event {
    border-right: 4px solid;
}

/* Class for events with special times */
.has-early-start {
    border-top-width: 3px !important;
    border-top-style: dashed !important;
}

.has-late-end {
    border-bottom-width: 3px !important;
    border-bottom-style: dashed !important;
}

/* Enhanced visibility for events */
.fc-event, 
.fc-timegrid-event, 
.fc-event-main, 
.fc-timegrid-event-harness, 
.custom-event,
.fc-event-forced-visible {
    border-width: 2px !important;
    font-weight: bold !important;
    padding: 2px 4px !important;
    min-height: 24px !important;
    position: absolute !important;
    z-index: 999 !important;
    margin: 1px 0 !important;
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
    pointer-events: auto !important;
    overflow: visible !important;
}

/* Manual event elements for backup rendering */
.manual-calendar-event {
    font-family: Arial, sans-serif;
    box-sizing: border-box;
    line-height: 1.3;
    transition: box-shadow 0.2s, transform 0.1s;
    z-index: 2001 !important;
    opacity: 1 !important;
    visibility: visible !important;
}

.manual-calendar-event:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important;
    transform: scale(1.03);
}

.manual-events-container {
    pointer-events: none;
    z-index: 2000 !important;
    position: absolute !important;
    inset: 0 !important;
}

/* Add extra specificity to ensure high visibility */
.calendar-container .manual-calendar-event,
#calendar .manual-calendar-event,
div.manual-calendar-event {
    visibility: visible !important;
    display: block !important;
    opacity: 1 !important;
    position: absolute !important;
    z-index: 3000 !important;
}

/* Debug overlay styling */
.debug-event {
    box-shadow: 0 0 8px rgba(0,0,0,0.3);
    margin-bottom: 5px;
    cursor: pointer;
    transition: transform 0.1s;
}

.debug-event:hover {
    transform: scale(1.05);
}

.debug-alert {
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

/* Extra specificity for user events to ensure visibility */
.user-event-visible,
.fc-event[data-is-current-user="true"],
.fc-timegrid-event[data-is-current-user="true"] {
    box-shadow: 0 2px 8px rgba(0,0,0,0.5) !important;
    z-index: 100 !important; /* Make sure user's events appear on top */
    opacity: 1 !important;
    border-width: 3px !important;
    padding: 3px 5px !important;
}

/* Make sure event containers are visible */
.fc-timegrid-event-harness {
    z-index: 50 !important;
    position: absolute !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Make individual events in the grid visible */
.planned-event, .current-event, .completed-event, .user-event {
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
}

/* Debug overlay */
.debug-event-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    pointer-events: none;
}

.debug-event {
    box-shadow: 0 0 5px rgba(0,0,0,0.5);
    margin-bottom: 5px;
}

.debug-dot {
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}
</style>
{% endblock %}